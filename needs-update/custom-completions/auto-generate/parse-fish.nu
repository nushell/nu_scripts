# a .fish complete file usually looks like a like
# `complete -c command -n '__fish_seen_subcommand_from arg' -a arg -l long -s short -d 'description'
# attempt to loosely pasrse it and convert to nu completions

# parse every .fish file in the current directory and make a .nu completions file of it
def build-completions-from-pwd [] {
    ls *.fish | par-each { |f|
        let out = ($f.name | str replace ".fish" ".nu")
        print $"building nushell completions from ($f.name)"
        build-completion $f.name $out
    }
}

# build a completion form a .fish file and generate a .nu file
def build-completion [fish_file: path, nu_file: path] {
    open $fish_file | parse-fish | make-commands-completion | str join "\n\n" | save $nu_file
}

# parse a .fish file based on autogenerated complete syntax
# returns a table of flags to arguments
# currently only handles complete's args that don't use boolean flags (e.g. -f)
def parse-fish [] {
    let data = (
        $in | tokenize-complete-lines
        | each { |tokens| $tokens | pair-tokens | translate-pairs }   # turn the tokens into a list of pairs
        | flatten                                 # merge them all into a top level label
    )
    # default every column in the table to "" to make processing easier
    # some values having null often breaks nu or requires lots of checking
     $data | columns | reduce -f $data { |c, acc| $acc | default "" $c }
     | default "" arguments
     | cleanup_subcommands # clean garbage subcommands
}

# tokenize each line of the fish file into a list of tokens
# make use of detect columns -n which with one like properly tokenizers arguments including across quotes
def tokenize-complete-lines [] {
    lines
    | where $it starts-with 'complete '         # only complete command lines
    | each { 
      str substring 9..                       # clear out complete command, keep args
      | str replace -a "\\\\'" ""             # remove escaped quotes ' which break detect columns
      | str replace -a "-f " ""               # remove -f which is a boolean flag we don't support yet
      | detect columns -n
      | transpose -i tokens
      | get tokens
    }
}

# turn a list of tokens for a line into a record of {flag: arg}
def pair-args [] {
    window 2 --remainder
    | each { |pair|
        let name = $pair.0 | map-flag-name
        let value = $pair.1 | unquote
        [
            {$name: $value}   # turn into a [{<flag> :<arg>}] removing quotes
        ]
    }
    | reduce { |it, acc| $acc | merge $it }                         # merge the list of records into one big record
}

def pair-tokens [] {
  window 2 --remainder | where $it.0 starts-with '-' | each { if $in.1 starts-with '-' { [$in.0] } else { $in } }
}

def translate-pairs [] {
  each {|pair|
    match $in.0 {
      '-c' | '--command' => { command: ($in.1 | unquote) }
      '-s' | '--short-option' => { short-option: ($in.1 | unquote) }
      '-l' | '--long-option' => { long-option: ($in.1 | unquote) }
      '-d' | '--description' => { description: ($in.1 | unquote) }
      '-o' | '--old-option' => { old-option: ($in.1 | unquote) }
      '-F' | '--force-files' => { force-files: true }
      '-f' | '--no-files' => { no-files: true }
      '-r' | '--require-parameter' => { require-parameter: true }
      '-x' | '--exclusive' => { require-parameter: true, no-files: true }
      '-a' | '--arguments' => { arguments: ($in.1 | unquote) }
      '-n' | '--condition' => { condition: ($in.1 | unquote) }
      '-k' | '--keep-order' => { keep-order: true }
      '-C' | '--do-complete' => { do-complete: ($in.1 | unquote) } # try to find all possible completions for the specified string. Otherwise use the current command line.
      '--escape' => { escape: true } # when used with -C escape special characters
      _ => { $'unknown_($in.0)': (if ($in | length) == 2 { $pair.1 }) }
    }
  }
  | reduce {|it,acc| $acc | merge $it }
}

def unquote [] {
    str trim -c "\'"   # trim '
    | str trim -c "\"" # trim "
}

# remove any entries which contain things in subcommands that may be fish functions or incorrect parses
def cleanup_subcommands [] {
    where ((not ($it.arguments | str contains "$")) 
        and (not ($it.arguments | str starts-with "-")) 
        and (not ($it.arguments starts-with "("))
    )
}

# from a parsed fish table, create the completion for it's command and sub commands
def make-commands-completion [] {
    let fishes = $in
    $fishes
    | where ('command' in ($fishes | columns))
    | get command
    | uniq         # command is cloned on every complete line
    | each { |command|
        $fishes | where command == $command | make-subcommands-completion [$command]
        | str join "\n\n"
    }
}

# make the action nu completion string from subcommand and args
# subcommand can be empty which will be the root command
def make-subcommands-completion [parents: list<string>] {
    let quote = '"' # a `"`

    let fishes = $in

    $fishes
    | group-by arguments                                                              # group by sub command (arguments flag)
    | transpose  name args                                                             # turn it into a table of name to arguments
    | each {|subcommand|
        [
            # description
            (
                if (('description' in ($subcommand.args | columns))
                    and ($subcommand.args.description != "")
                    and ('condition' in ($subcommand.args | columns))
                    and ($subcommand.args.condition == "__fish_use_subcommand")
                ) { $"# ($subcommand.args.description)\n" }
            )
            # extern name
            $'extern "($parents | append $subcommand.name | str join " " | str trim)"'
            # params
            " [\n"
                (
                    $fishes
                    | if ('condition' in ($subcommand.args | columns)) {
                        if ($subcommand.name != "") {
                            where ($it.condition | str contains $subcommand.name)                     # for subcommand -> any where n matches `__fish_seen_subcommand_from arg` for the subcommand name
                        } else {
                            where ($it.condition == "__fish_use_subcommand") and ($it.arguments == "")         # for root command -> any where n ==  __fish_use_subcommand and a is empty. otherwise a means a subcommand
                        }
                    } else {
                        $fishes                                                               # catch all
                    }
                    | build-flags
                    | str join "\n"
                )
                "\n\t...args"
            "\n]"
        ]
        | str join
    }
}

# build the list of flag string in nu syntax
# record<c, n, a, d, o> -> list<string>
def build-flags [] {
    $in
    | each { |subargs|
        if ('long-option' in ($subargs | columns)) and ($subargs.long-option != "") {
            [
                "\t--" $subargs.long-option
                (
                  [
                    (if ('short-option' in ($subargs | columns)) and ($subargs.short-option != "") { [ "(-" $subargs.short-option ")" ] | str join })
                    (if ('description' in ($subargs | columns)) and ($subargs.description != "") { [ "\t\t\t\t\t# " $subargs.description ] | str join })
                  ] | str join
                )
            ] | str join
        } else if ('short-option' in ($subargs | columns)) and ($subargs.short-option != "") {
            [
                "\t-" $subargs.short-option
                (if ('description' in ($subargs | columns)) and ($subargs.description != "") { [ "\t\t\t\t\t# " $subargs.description ] | str join })
            ] | str join
        }
    }
}
